/**
 * This file is part of libcommon.
 *
 * libcommon is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, orF
 * (at your option) any later version.
 *
 * libcommon is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with libcommon.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef COMMON_SAMPLING_IMPL_HPP
#define COMMON_SAMPLING_IMPL_HPP

#include <cinttypes>
#include <random>

namespace common::details::sampling {

    /**
     * Wrapper to generate the random numbers
     */
    struct RandomGenerator {
        std::mt19937_64 m_generator;
        std::uniform_real_distribution<double> m_distribution;

        RandomGenerator(uint64_t seed): m_generator(seed) { }
        double operator () (){ return m_distribution(m_generator); }
    };

    // Vitter J. S. An efficient algorithm for sequential random sampling. Rapports de Recherche N* 624. 1987
    int64_t next(RandomGenerator& dblrand, int64_t previous_index, int64_t* m_, int64_t* N_){
        // Code extrapolated and adapted from the old randomgen utility.
        // The following is legacy code, I trust it works as it worked 4 years ago.
        int64_t N = *N_;
        int64_t m = *m_;

        int64_t qu1 = N+1-m;
        double qu1d = (double) qu1;
        double nmin1inv = 1.f / ( ((double)m) - 1.f);
        int64_t S = std::numeric_limits<int64_t>::max();

        while(true){
            // [D2] generate U, X, S
            double U, X;
            U = dblrand(); // uniform distribution in [0,1]

            do{
                X = N * (1 - pow(dblrand(), 1.f/m)); // beta distribution in [0,N] with with a=1, b=m
                S = floor(X);
            } while(S >= qu1); // N -m +1

            // [D3] Compare S with the approx of the distribution
            double y1 = exp(log( U *N / qu1d) * nmin1inv);
            double Vprime = y1 * ( - (X/N) +1) * (qu1d / (qu1d - S));
            if(Vprime <= 1) break;

            // [D4] Compare S with the actual distribution
            double y2 = 1;
            double top = N -1;
            double bottom;
            int64_t limit;
            if(m+1 > S){
                bottom = N -m;
                limit =  N -S;
            } else {
                bottom = -1.0 -S +N;
                limit = qu1;
            }
            int64_t k;
            for(k = N+1; k >= limit; k--){
                y2 = (y2 * top) / bottom;
                top--; bottom--;
            }

            if( (((double)N) / ((double) (N -X))) >= (y1 * exp(log(y2) * nmin1inv)) ){ // Accept S
                Vprime = exp( log(dblrand()) * nmin1inv);
                break; // exit from the loop
            }
        } // end loop

        // [D5] select record (S+1)
        N = N -1 -S;
        m--;

        *m_ = m;
        *N_ = N;
        return previous_index + S +1;
    }

    template<typename T>
    void implementation(const T* input, uint64_t input_sz, T* output, uint64_t& num_samples, uint64_t seed){
        if(num_samples > input_sz) { num_samples = input_sz; } // overflow

        RandomGenerator rnd{seed};
        int64_t i = 0; // index in the output array
        int64_t k = -1; // the first value that can be generated by the sampling algorithm will start from 0
        int64_t m = num_samples; // total number of samples to generate
        int64_t N = input_sz; // total size of the input
        while(m > 0){
            k = next(rnd, k, &m, &N);

            output[i] = input[k];
            i++; // next iteration
        }
    }
} // namespace

#endif //COMMON_SAMPLING_IMPL_HPP
